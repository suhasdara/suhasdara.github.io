{
    "componentChunkName": "component---src-templates-blog-temp-js",
    "path": "/blogs/python-function-parameters",
    "result": {"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Python Function Parameters\",\n  \"date\": \"2021-11-04T00:00:00.000Z\",\n  \"slug\": \"/blogs/python-function-parameters\",\n  \"tags\": [\"tech\"],\n  \"postType\": \"blog\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In Python, or every programming language, functions are one of the larger\\nbuilding blocks. Functions allow reusing blocks of code and eliminate code\\nduplication. But, not everyone is fully aware of all the different ways to\\npass inputs to functions. That is what I will be exploring in this blog.\"), mdx(\"p\", null, \"Let's begin with a simple way of defining functions. A function can be\\ndescribed with three steps:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Take inputs\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Manipulate the inputs (the function body)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Return an output\")), mdx(\"p\", null, \"As a note, moving forward, I will be referring to the inputs within the\\nfunction definition as parameters, and the actual input values used when\\ninvoking the function as arguments.\"), mdx(\"p\", null, \"So, this is what a typical function looks like in Python, as you may already\\nknow:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def function_name(parameter1, parameter2, ...):\\n    # indentation important\\n    # manipulation of input parameters\\n    return  # something\\n\")), mdx(\"p\", null, \"So let's explore the different ways that arguments can be passed in to\\nfunctions. When learning about functions, we are usually introduced to them\\nwith a fixed number of parameters. These parameters are \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"positional\"), \" meaning\\nthe position of the arguments when invoking the function will matter. If a\\nfunction with a fixed number of parameters is not invoked with the same number\\nof arguments as the number of parameters, it will raise an error.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def multiply(num1, num2):\\n    print(f\\\"Multiplying {num1} and {num2}\\\")\\n    return num1 * num2\\n\\nmultiply(2, 2)     # returns 4\\nmultiply(2, 2, 2)  # error num arguments != num parameters\\n\")), mdx(\"p\", null, \"Additionally, when invoking the function, we can either use positional\\narguments or keyword arguments to specify the parameters. As a syntax rule,\\npositional arguments always precede keyword arguments. This is because the\\npositional arguments are first matched with their respective parameters before\\nutilizing keyword arguments to target the remaining parameters. If a keyword\\nargument does not target a parameter that exists, it will raise an error.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def divide(dividend, divisor):\\n    print(f\\\"Dividing {dividend} by {divisor}\\\")\\n    return dividend / divisor\\n\\ndivide(4, 2)                   # both positional args\\ndivide(dividend=4, divisor=2)  # both named args\\ndivide(divisor=2, dividend=4)  # both named args in a different order also works\\ndivide(4, divisor=2)           # mix of positional and keyword args\\n\\ndivide(dividend=4, 2)          # will raise an error as positional args should be first\\ndivide(2, dividend=4)          # will raise an error as 2 is already assigned to `dividend` positionally\\ndivide(2, quotient=4)          # will raise an error as `quotient` parameter does not exist\\n\")), mdx(\"p\", null, \"However, there are often occasions where having a default value for a\\nparameter is useful, usually for specifying default settings to the function.\\nIn Python, we can supply default values to parameters by specifying them in\\nthe function definition. This makes the parameter optional and if no value is\\nsupplied when invoking the function, the default value is utilized. However,\\nthe optional parameters, known as keyword parameters, can only be specified\\nafter 0 or more positional parameters in the function definition.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def exponent(power, base=10):\\n    print(f\\\"Raising {base} to the power {power}\\\")\\n    return base ** power\\n\\nexponent(3, base=2)  # returns 8\\nexponent(3, 2)       # default parameters can be specified through position, returns 8\\nexponent(3)          # uses default `base`, returns 1000\\n\\nexponent()           # `power` does not have a default value, so raises error\\n\")), mdx(\"p\", null, \"Now, suppose we want to expand our earlier \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"multiply\"), \" function to multiply as\\nmany numbers as we would like. To accomplish this task, we would require a\\nfunction that accepts a variable number of arguments. Granted, we could create\\na function that just accepts a list or an iterable as its only positional\\nargument, but that would require the creation of additional containers and\\nalso may require type checking inside the function to make sure we received an\\niterable. Wouldn't it be much easier if Python created that list (technically\\na tuple) for us? That is exactly what the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"*args\"), \" parameter accomplishes.\"), mdx(\"p\", null, \"Let's take a short detour here. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"*\"), \" in question here is not the binary\\noperator for multiplication, but actually a packing/unpacking operation. We\\ncan \\\"unpack\\\" an iterable into arguments to a function when invoking it, or\\nconversely, we can \\\"pack\\\" function parameters into an iterable for use inside\\nthe function body. There are actually two operators here: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"*\"), \" is used for\\npacking/unpacking tuples, lists, sets, and keys of dictionaries, while \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"**\"), \" is\\nused for packing/unpacking dictionary item pairs.\"), mdx(\"p\", null, \"First, let's see some examples for unpacking of iterables:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def exponent(power, base):\\n    print(f\\\"Raising {base} to the power {power}\\\")\\n    return base ** power\\n\\nargs = [3, 2]\\nexponent(*args)                      # unpacking the list into positional args\\nargs = {3, 2}\\nexponent(*args)                      # unpacking the set works but unpredictable order and output\\nkwargs = {\\\"power\\\": 3, \\\"base\\\": 2}\\nexponent(**kwargs)                   # unpacking the dictionary into keyword args\\n\\nargs = [3]\\nkwargs = {\\\"base\\\": 2}\\nexponent(*args, **kwargs)            # unpacking positional and keyword args\\n\\nexponent(*[3, 2, 1])                 # will raise an error as too many args\\nexponent(*[3])                       # will raise an error as too few args\\nexponent(**{\\\"power\\\": 3, \\\"blah\\\": 2})  # will raise an error as unexpected keyword arg\\n\")), mdx(\"p\", null, \"Going back to the variable number of positional parameters \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"*args\"), \", we can\\nmake an association that if we are unpacking arguments when invoking a\\nfunction, we can similarly pack the parameters inside the function itself. We\\ncan either have completely variable number of parameters (0 to computer limit)\\nor a few fixed positional parameters and then a variable number of additional\\nparameters (fixed \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" to computer limit). It is generally a good practice to\\ngroup the variable positional parameters along with the fixed positional\\nparameters and have the keyword parameters follow if any.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"# one number followed by variable amount of numbers followed by an optional factor\\n# *nums is the packing of variable positional parameters into nums\\ndef multiply(num, *nums, factor=1):\\n    print(num, nums, factor)\\n    ret = num * factor\\n    # nums is just a tuple that can be iterated over\\n    for new_num in nums:\\n        ret *= new_num\\n    return ret\\n\\nmultiply(2)                  # returns 2, num=2, nums is (), factor is default 1\\nmultiply(2, 3, 4, 5)         # returns 120, num=2, nums is (3, 4, 5), factor is default 1\\nmultiply(2, factor=0.5)      # returns 1, num=2, nums is (), factor is 0.5\\n\\n# the following is equivalent to multiply(2, 3, 4, 5, factor=0.5)\\nargs = [2, 3, 4, 5]\\nmultiply(*args, factor=0.5)  # returns 60, num=2, nums is (3, 4, 5), factor is 0.5\\n\\nmultiply()                   # will raise an error as `num` is still required\\nmultiply(factor=2)           # will raise an error as `num` is still required\\nmultiply(2, factor=2, 3)     # will raise an error as keyword arg precedes positional arg\\n\")), mdx(\"p\", null, \"Similarly, we can have a variable number of keyword parameters in the form of\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"**kwargs\"), \". Any keyword arguments that do not match any of the parameter names\\nwhen invoking a function will get packed into a dictionary inside the\\nfunction. The variable number of keyword parameters can be used by itself if\\nall we want are key-value pairs inside the function, but they typically\\nfollow either or all of the following: fixed positional parameters, variable\\npositional parameters, and fixed keyword parameters.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"# one number followed by an optional factor followed by named numbers\\n# **nums is the packing of variable keyword parameters into nums\\ndef multiply(num, factor=1, **nums):\\n    print(num, factor, nums)\\n    ret = num * factor\\n    # nums is just a dictionary that can be iterated over\\n    for name in nums:\\n        new_num = nums[name]\\n        print(f\\\"Multiplying by {name}={new_num}\\\")\\n        ret *= new_num\\n    return ret\\n\\nmultiply(2)                   # returns 2, num=2, factor is default 1, nums is {}\\nmultiply(2, a=3, b=4, c=5)    # returns 120, num=2, factor is default 1, nums is {'a':3, 'b':4, 'c':5}\\nmultiply(2, factor=0.5)       # returns 1, num=2, factor is 0.5, nums is {}\\nmultiply(2, factor=0.5, a=3)  # returns 3, num=2, factor is 0.5, nums is {'a':3}\\nmultiply(2, a=3, factor=0.5)  # same as above, but bad style to put variables first\\n\\n# the following is equivalent to multiply(num=2, a=3, b=4, c=5, factor=0.5)\\nargs = {'num':2, 'a':3, 'b':4, 'c':5}\\nmultiply(**args, factor=0.5)  # returns 60, num=2, factor is 0.5, nums is {'a':3, 'b':4, 'c':5}\\n\\nmultiply()                    # will raise an error as `num` is still required\\nmultiply(factor=2, a=3, b=4)  # will raise an error as `num` is still required\\n\")), mdx(\"p\", null, \"In general, the good practice to avoid unexpected behaviors when passing\\narguments to a function is to use the following order of parameters in the\\nfunction definition and also when invoking the function:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Fixed positional parameters\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Variable positional parameters\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Fixed keyword parameters\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Variable keyword parameters\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def example(arg1, arg2, *args, kwarg=None, **kwargs):\\n    print(arg1, arg2, args, kwarg, kwargs)\\n\\nexample(\\n  \\\"hello\\\",                   # arg1\\n  \\\"world\\\",                   # arg2\\n  \\\"did\\\", \\\"you\\\", \\\"receive\\\",   # args\\n  kwarg=\\\"my\\\",                # kwarg\\n  hidden=\\\"message\\\"           # kwargs\\n)\\n\")), mdx(\"p\", null, \"I hope this example-heavy blog is actually useful to learn positional,\\nkeyword, and variable parameters. The packing and unpacking operator often\\nconfused me but when I understood what it meant, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"*args\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"**kwargs\"), \"\\nsuddenly made a lot more sense.\"));\n}\n;\nMDXContent.isMDXComponent = true;","timeToRead":3,"fields":{"excerpt":"In Python, or every programming language, functions are one of the larger\nbuilding blocks. Functions allow reusing blocks of code and eliminate code\nduplication. But, not everyone is fully aware of all the different ways to\npass inputs to functions. That is what I will be exploring in this blog."},"frontmatter":{"title":"Python Function Parameters","date":"2021-11-04T00:00:00.000Z","tags":["tech"],"slug":"/blogs/python-function-parameters"}}},"pageContext":{}},
    "staticQueryHashes": ["63159454"]}