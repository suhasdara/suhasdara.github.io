{"componentChunkName":"component---src-templates-blog-temp-js","path":"/blogs/python-strings","result":{"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Understanding Strings in Python\",\n  \"date\": \"2021-09-20T00:00:00.000Z\",\n  \"slug\": \"/blogs/python-strings\",\n  \"tags\": [\"tech\"],\n  \"postType\": \"blog\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Learn the differences between different string literals in Python and how\\nescape characters work differently between them. Also understand the encoding\\nand decoding functionality with Python strings.\"), mdx(\"p\", null, \"While working on a recent project, I was dealing with a lot of strings\\ncontaining Unicode characters. For a long time I was trying to print the raw\\nunicode codes for debugging purposes and went down a rabbit hole trying to\\nunderstand the difference between raw strings, byte strings, encoding, decoding\\nand a lot more. It was a little frustrating to be unable to figure out\\nsomething seemingly simple. I want to demystify the experience that I had with strings\\nin Python.\"), mdx(\"p\", null, \"First let's get the basics out of the way... You can use either double quotes\\nor single quotes to create strings in Python. You can also use triple quotes\\n(\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'''\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\"\\\"\\\"\"), \") to create multi-line strings.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"s1 = 'This is a string'\\ns2 = \\\"This is also a string\\\"\\nm1 = '''This is a\\nmulti line string'''\\nm2 = \\\"\\\"\\\"This is also a\\nmulti line string\\\"\\\"\\\"\\n\")), mdx(\"p\", null, \"Strings can have characters \\\"escaped\\\" out of the string using the backslash\\nto represent some other entities. Common ones include \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\\n\"), \" for representing\\na newline or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\\t\"), \" for representing a tab. To use the single quote inside a\\nsingle-quote-string, you have to escape it with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\\'\"), \" and similarly for using\\na double quote inside a double-quote-string, you have to escape it with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\\\\\"\"), \".\\nTo get a backslash itself within a string you have to escape it like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\\\\\\\"), \".\"), mdx(\"p\", null, \"Sometimes, you may have a string with a lot of backslashes. Python has a\\nway to reduce the clutter of escaped backslashes within strings backslashes.\\nIn Python, you can create raw strings, in which the backslash does not trigger\\nan escape sequence and is treated as a normal character. This can be useful in\\ncertain situations such as dealing with paths on a Windows system. These raw\\nstrings are represented as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"r\\\"\\\"\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"s1 = \\\"I\\\\thave\\\\tescape\\\\tcharacters\\\"\\nprint(s1)  # prints \\\"I  have    escape  characters\\\"\\ns2 = r\\\"I\\\\tdon't\\\\thave\\\\tescape\\\\tcharacters\\\"\\nprint(s2)  # prints \\\"I\\\\tdon't\\\\thave\\\\tescape\\\\tcharacters\\\"\\n\")), mdx(\"p\", null, \"In Python 3.5, format strings were first introduced into Python. This allowed\\nthe string representations of variables to be directly injected into strings.\\nFormat strings are represented as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"f\\\"\\\"\"), \" and you can inject the value of any\\nvariable into the string using curly braces (and escape curly braces using\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"{{\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"}}\"), \"). Format strings can also be combined with raw strings to\\nform raw format strings (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rf\\\"\\\"\"), \"). For example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"age = 20\\ns = f\\\"I am {age} years old\\\"\\nprint(s)  # prints \\\"I am 20 years old\\\"\\ns = rf\\\"I am {{ {age} }} years old \\xAF\\\\_(\\u30C4)_/\\xAF\\\"\\nprint(s)  # prints \\\"I am { 20 } years old \\xAF\\\\_(\\u30C4)_/\\xAF\\\"\\n\")), mdx(\"p\", null, \"But this is all basics that you already likely know. Let's move to the parts\\nthat can get confusing.\"), mdx(\"p\", null, \"First, what exactly is a string? It is a \\\"string\\\" of characters you may say.\\nBut what is a character? In crude terms, a character is a single byte of\\ninformation that represents something that humans can understand. The mapping\\nthat represents character to bytes conversion is an encoding format known as\\nASCII, which covers 128 different basic characters and escape characters. For\\nnow, let's assume that this is the only way characters can be encoded.\"), mdx(\"p\", null, \"Every character in ASCII is represented by 8 bits of data, which is the binary\\nrepresentation of the character. For example, the character \\\"K\\\" in binary\\n(base-2, the language of computers) is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"01001011\"), \". Similarly, other number\\nsystems such as octal (base-8) or hexadecimal (base-16) can be used to\\nrepresent binary more succinctly. For example, the equivalent for character\\n\\\"K\\\" in octal is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0113\"), \" and in hexadecimal is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0x4b\"), \".\"), mdx(\"p\", null, \"Python allows you to write your strings using octal or hexadecimal to\\nrepresent the characters. A byte (or 8 bits) of data can be represented by\\nthree digits of octal or two digits of hexadecimal. This is the reason Python\\nhas adopted the standard from C to allow three digit escape sequences of the\\nsort \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\\ooo\"), \" (where \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"o\"), \" is a valid octal digit) to represent octal mappings,\\nand two digit escape sequences of the sort \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\\xhh\"), \" (where \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"h\"), \" is a valid hex\\ndigit) to represent hex mappings.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"a = \\\"K\\\"         # this is K\\no = \\\"\\\\113\\\"      # this is also K\\nh = \\\"\\\\x4b\\\"      # this is also K\\nprint(a, o, h)  # prints \\\"K K K\\\"\\n\")), mdx(\"p\", null, \"However, with a growing web and inclusion of languages across the world and\\nemoticons, a new character encoding standard called UTF-8 was proposed in\\n1992. Here, we move from a single byte per character to using between one and\\nfour bytes per character. This is called a Unicode representation of a\\ncharacter, which is actually backwards compatible with ASCII. Every character\\nyou have ever come across on the Internet is likely to have been encoded with\\nUTF-8.\"), mdx(\"p\", null, \"The number of characters that can be encoded increased from 2\", mdx(\"sup\", null, \"8\"), \"\\n(256) in ASCII to 2\", mdx(\"sup\", null, \"21\"), \" (2,097,152) in UTF-8. However, currently\\nthere are only 1,112,064 valid UTF-8 \\\"codepoints\\\", which each translate to a\\ndifferent character. This means that the largest valid UTF-8 codepoint is\\ncurrently \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0x10ffff\"), \", though in the future it could be up to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0x1fffff\"), \".\"), mdx(\"p\", null, \"As an example, the character \\\"\\u20AC\\\" has a codepoint of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0x20ac\"), \". This codepoint\\ntranslates to the hexadecimal bytes \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0xe2 0x82 0xac\"), \". As this translation from\\ncodepoint to bytes is not straightforward, to understand exactly how Unicode\\ncodepoints translate to their one to four byte representations, you can read\\nmore about the UTF-8 encoding\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/UTF-8#Encoding\"\n  }, \"here\"), \". The UTF-8 encoding is\\nbackwards compatible with ASCII because any character with a UTF-8 codepoint\\nbelow \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0x7f\"), \" (128) translates exactly into the same hexadecimal bytes.\"), mdx(\"p\", null, \"In Python, you can include Unicode codepoints in strings using escape\\nsequences similar to how you can include octal or hexadecimal representations\\nof characters. To include any Unicode character below the codepoint \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0xffff\"), \"\\nin a string, you can use escape sequences of the sort \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\\uhhhh\"), \" (where \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"h\"), \" is\\na valid hex digit and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hhhh\"), \" is a codepoint). To include absolutely any\\nUnicode character, you can use escape sequences of the sort \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\\Uhhhhhhhh\"), \"\\ninstead. Bear in mind however, that even though the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\\U\"), \" escape sequence\\nexpects 8 hexadecimal characters, the largest codepoint that is supported\\nwithout throwing an error is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\\U0010ffff\"), \" as explained above.\"), mdx(\"p\", null, \"So, we can expand on our previous representations as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"u = \\\"\\\\u004b\\\"      # this is also K\\nU = \\\"\\\\U0000004b\\\"  # this is also K\\nprint(u, U)       # prints \\\"K K\\\"\\n\")), mdx(\"p\", null, \"Now based on what we've learned, you may expect that the string\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\"\\\\xe2\\\\x82\\\\xac\\\"\"), \" would convert to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\"\\u20AC\\\"\"), \" based on the UTF-8 encoding system.\\nHowever, this is where things may get confusing because Python deals with\\nbyte representations included in strings on an individual byte basis. It uses\\nthe UTF-8 encoding on a per-byte basis instead of sets of bytes. A reason for\\nthis behavior is because there are encoding formats other than UTF-8, and it\\nwould be incorrect for Python to assume the encoding format of the bytes in\\nthe string. As an example try the following code, and you will see the\\nunexpected results:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"d = \\\"\\u20AC\\\"             # this is a \\u20AC\\nu = \\\"\\\\u20ac\\\"        # this is also a \\u20AC\\nU = \\\"\\\\U000020ac\\\"    # this is also a \\u20AC\\nb = \\\"\\\\xe2\\\\x82\\\\xac\\\"  # this is NOT a \\u20AC, instead is \\xE2\\xAC\\nprint(d, u, U, b)   # prints \\\"\\u20AC \\u20AC \\u20AC \\xE2\\xAC\\\"\\n\")), mdx(\"p\", null, \"The bytes representation of \\\"\\u20AC\\\" I mentioned earlier translates to \\\"\\xE2\\xAC\\\" instead\\nbased on the individual byte translation pattern. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0xe2\"), \" maps to \\\"\\xE2\\\", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0x82\"), \"\\nis a non-printable character, and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0xac\"), \" maps to \\\"\\xAC\\\". I will explain exactly\\nwhy this happens in more detail towards the end.\"), mdx(\"p\", null, \"This is where we need to separate the concept of strings from raw bytes in\\nPython. Before moving forward, I would like to make the difference between\\n\\\"encoded\\\" and \\\"decoded\\\" clear in terms of Python. In Python, encoding means\\nconverting a string of characters into the raw bytes that it represents based\\non an encoding scheme such as UTF-8. Similarly, decoding means converting raw\\nbytes into a string of characters based on an encoding scheme. But what do\\nthese raw bytes look like?\"), mdx(\"p\", null, \"Raw bytes are stored as something called byte literals. Byte literals\\nlook similar to strings in code, but the characters are instead auto-encoded\\ninto bytes using the UTF-8 encoding scheme on individual characters unless\\nthey are already encoded into bytes. Byte literals are represented using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"b\\\"\\\"\"), \"\\nor \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"b''\"), \". However, an important thing to note is that byte literals only allow\\nfor characters up to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0xff\"), \". This means that Unicode is not supported by byte\\nliterals and the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\\u\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\\U\"), \" escapes do not work!(\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"!!\"), \").\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"d = b\\\"\\u20AC\\\"         # does not work, throws an error!\\nu = b\\\"\\\\u20ac\\\"    # works like a \\\"raw\\\" byte literal as \\\\u is unrecognized\\nru = rb\\\"\\\\u20ac\\\"  # exactly same as above\\nprint(u, ru)     # prints \\\"b'\\\\\\\\u20ac' b'\\\\\\\\u20ac'\\\" denoting byte literals\\n\")), mdx(\"p\", null, \"Additionally, a string can be newly defined as a set of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"individual\"), \" bytes\\nthat are auto-decoded using the UTF-8 encoding scheme unless already decoded.\\nNotice the use of the word \\\"individual\\\". This individual byte behavior can be\\n\\\"escaped\\\" using either \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\\u\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\\U\"), \" to induce two to four byte behavior and\\ndecode the rarer Unicode characters.\"), mdx(\"p\", null, \"Now, byte literals can be decoded using any encoding format in which they form\\na valid sequence of bytes. When the bytes get decoded using an encoding\\nformat, they turn into a string. Similarly, a string can get encoded into byte\\nliterals using any encoding format. So now if we try to print a byte literal\\nwith the byte representation of the \\\"\\u20AC\\\" character, you will notice it stays\\nas bytes, until it is encoded using UTF-8.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"b = b\\\"\\\\xe2\\\\x82\\\\xac\\\"     # this is a bytes literal representing \\u20AC in UTF-8\\nprint(type(b), b)       # prints \\\"<class 'bytes'> b'\\\\xe2\\\\x82\\\\xac'\\\"\\nd = b.decode(\\\"utf-8\\\")   # we decode the byte literal using UTF-8\\nprint(type(d), d)       # prints \\\"<class 'str'> \\u20AC\\\"\\ne = d.encode(\\\"utf-8\\\")   # we can encode back into byte literal using UTF-8\\nprint(type(e), e)       # prints \\\"<class 'bytes'> b'\\\\xe2\\\\x82\\\\xac'\\\"\\n\\nf = b.decode(\\\"utf-16\\\")  # this will error out\\nf = d.encode(\\\"ascii\\\")   # this will error out\\n\")), mdx(\"p\", null, \"As we see above, we can freely convert between strings and byte literals\\nusing an encoding format. However, if we try to decode bytes using an\\nencoding format where the bytes do not form a valid sequence, or if we try to\\nencode a string into bytes using an encoding format that does not support\\nthe characters of the string, we will see errors.\"), mdx(\"p\", null, \"To end off, as I promised earlier, I will explain why \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\"\\\\xe2\\\\x82\\\\xac\\\"\"), \" does\\nnot actually translate to \\u20AC. There is an important point to note, which is the\\ndifference between byte sequences inside strings and inside byte literals.\\nInside byte literals, the byte sequences are exactly what they seem like.\\nHowever, inside strings, the bytes actually represent the Unicode characters\\nbelow \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0xff\"), \". If they are non-printable they get displayed as the bytes,\\nhowever, if they are printable, we see the actual character. In UTF-8,\\ncharacters between \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0x80\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0xff\"), \" need two bytes of information as opposed\\nto one byte for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0x7f\"), \" and below (remember ASCII compatibility?). You can see\\nthese principles unfurl:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"s = \\\"\\\\x60\\\"            # below 0x7f\\nprint(s, s.encode())  # \\\"\\\\x60\\\" == b\\\"\\\\x60\\\"\\nu = \\\"\\\\xe0\\\"            # above 0x80\\nprint(u, u.encode())  # \\\"\\\\xe0\\\" == b\\\"\\\\xc3\\\\xa0\\\" != b\\\"\\\\xe0\\\"\\nb = b\\\"\\\\xe0\\\".decode()  # error, this is actually invalid in UTF-8!\\n\\n# our old example, now understood\\ne = \\\"\\\\xe2\\\\x82\\\\xac\\\"\\nprint(e, e.encode())  # \\\"\\\\xe2\\\\x82\\\\xac\\\" == b\\\"\\\\xc3\\\\xa2\\\\xc2\\\\x82\\\\xc2\\\\xac\\\" != b\\\"\\\\xe2\\\\x82\\\\xac\\\"\\n\")), mdx(\"p\", null, \"Overall, I hope this gives some insights into how strings work in Python.\\nWhile some concepts are specific to Python, some concepts are much more\\ngeneralized over all programming languages. If you want more resources about\\nstrings in Python or UTF-8 in general, you can check these out:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://docs.python.org/3/reference/lexical_analysis.html#literals\"\n  }, \"String and Bytes\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://en.wikipedia.org/wiki/UTF-8#Encoding\"\n  }, \"UTF-8 Encoding\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://docs.python.org/3/library/codecs.html#standard-encodings\"\n  }, \"Other Encoding Formats\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://docs.python.org/3/library/codecs.html#text-encodings\"\n  }, \"\\nOther Encoding Formats useful for Pickling and Debugging\\n\"))));\n}\n;\nMDXContent.isMDXComponent = true;","timeToRead":6,"fields":{"excerpt":"Learn the differences between different string literals in Python and how\nescape characters work differently between them. Also understand the encoding\nand decoding functionality with Python strings.","miscTimeToRead":6},"frontmatter":{"title":"Understanding Strings in Python","date":"2021-09-20T00:00:00.000Z","tags":["tech"],"slug":"/blogs/python-strings"}}},"pageContext":{}},"staticQueryHashes":["63159454"]}