{"componentChunkName":"component---src-templates-blog-temp-js","path":"/blogs/python-decorators","result":{"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Python Decorators\",\n  \"date\": \"2022-01-14T00:00:00.000Z\",\n  \"slug\": \"/blogs/python-decorators\",\n  \"tags\": [\"tech\"],\n  \"postType\": \"blog\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In Python, decorators are often shrouded by a layer of mystery. We tend to use\\nthem without understanding how they work, but if understood properly, they can\\nreally improve our efficiency. This blog will cover the fundamentals of\\ndecorators, and assumes that you have an understanding of how functions work.\"), mdx(\"p\", null, \"If you are not fully familiar with how function parameters and arguments work\\nin Python, I suggest you first take a look at my previous blog post on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/blogs/python-function-parameters\"\n  }, \"Python\\nfunction parameters\"), \", which I wrote to lead\\nup to this blog on decorators.\"), mdx(\"p\", null, \"Decorators are functions that modify the functionality of other functions.\\nThat may sound straightforward, but, to understand decorators, we have to\\nbegin with nested functions and functions as variables.\"), mdx(\"p\", null, \"Nested functions are functions inside functions. We can limit the scope of\\nfunctions similar to how we can limit the scope of variables from global to\\nlocal. If function B is defined inside function A, we cannot call function B\\nfrom outside function A. Nested functions are useful for creating helper\\nfunctions and also for recursive functions, but as we will see, they also\\nserve a purpose in decorators. Nested functions also have access to all the\\nvariables that are available in the scope of the outer function.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def convert(cm):\\n    def inches():\\n         return cm / 2.54\\n    print(f\\\"{cm}cm is {inches()}in.\\\")  # calls the nested inches function\\n\\nconvert(2540)  # this will print the conversion\\ninches()       # this will error because inches is not in scope\\n\")), mdx(\"p\", null, \"A property of functions that many people overlook is that they are essentially\\nsegments of code stored in a variable. This becomes much more obvious with the\\nuse of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"lambda\"), \" functions.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def two_times(x):\\n    print(x * 2)\\n\\ndouble = two_times\\ndouble(5)                         # prints 10\\n\\n# not pythonic to store lambdas in variables, but just for the example\\ndouble2 = lambda x: print(x * 2)\\ndouble2(5)                        # prints 10\\n\")), mdx(\"p\", null, \"Just like any other variables, functions can be assigned to other variables\\nand can be passed as arguments to functions:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def call(func, *args, **kwargs):\\n    func(*args, **kwargs)\\n\\ndef multiply(v1, v2):\\n    print(v1 * v2)\\n\\ncall(multiply, 7, 8)              # passing multiply to \\\"call\\\" to get invoked by \\\"call\\\"\\ncall(multiply, v1=7, v2=8, v3=0)  # errors as there is no v3 argument for multiply\\n\")), mdx(\"p\", null, \"Similarly, just like other variables, functions can also be returned from\\nfunctions. The inner function is tied to the outer function and cannot be\\naccessed outside the outer function unless returned by an invocation of the\\nouter function.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def mult_table(x):\\n    def num(y):\\n        return x * y\\n    return num\\n\\nfive_table = mult_table(5)   # returns a function computing 5 * y\\nseven_table = mult_table(7)  # returns a function computing 7 * y\\nprint(five_table(8))         # prints 40\\nprint(seven_table(11))       # prints 77\\nnum(10)                      # this will error because num is not in scope\\n\")), mdx(\"p\", null, \"From the previous two examples, we are already close to understanding what\\ndecorators actually do. A decorator essentially takes in function, wraps it in\\nanother function to improve the functionality of the original function, and\\nthen returns the new wrapper function.\"), mdx(\"p\", null, \"Sounds like a mouthful! Let's break it down with a simple decorator example.\\nSay we have a bunch of functions that call each other, and we are receiving an\\nerror somewhere. But, we are unable to figure out where. We resort to debugging\\nwith print statements: the usual printing of parameters, printing of return\\nvalues etc. However, we have too many functions and adding prints to every\\nsingle function is too time-consuming. How nice would it be if we could just\\nattach a \\\"template debugger\\\" to every function that does the same thing? Well,\\nthat's where a decorator will come in handy - it will decorate (wrap) each\\nfunction with another function, in this case a template debugger.\"), mdx(\"p\", null, \"If we do debugging the cumbersome way, we would have to edit every single\\nfunction to add debugging statements, not to mention that each function could\\nhave a different number of parameters and return values, rendering simple copy\\nand paste techniques useless. But, anyway, this is probably how we would do\\nit:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def func(a1, a2, a3, kw1='a', kw2='b', kw3='c'):\\n    # essentially can be executed before the function\\n    print(f\\\"debug enter func\\\")\\n    print(f\\\"debug params: {a1} {a2} {a3} {kw1} {kw2} {kw3}\\\")\\n    ret = (a1 + a2 + a3, kw1 + kw2 + kw3)\\n    # essentially can be executed after the function\\n    print(f\\\"debug return: {ret}\\\")\\n    print(f\\\"debug exit func\\\")\\n    return ret\\n\\nfunc(1, 2, 3, 'x', 'y', 'z')  # this should print the params and return value\\n\")), mdx(\"p\", null, \"To create a template debug function, we move the debugging statements from\\ninside the actual function into an external wrapper. The following is an\\nexample of a debug decorator:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def debug(func):                                  # decorator\\n    def wrapper(*args, **kwargs):                 # wrapper that executes extra code\\n        print(f\\\"debug enter {func.__name__}\\\")\\n        print(f\\\"debug params: {args}, {kwargs}\\\")\\n        ret = func(*args, **kwargs)               # actual function invocation\\n        print(f\\\"debug return: {ret}\\\")\\n        print(f\\\"debug exist {func.__name__}\\\")\\n        return ret                                # forwarding return value from actual invocation\\n    return wrapper                                # making the wrapper available outside decorator scope\\n\\ndef linear(m, x, b=0):                            # function that will be decorated\\n    return m * x + b\\n\\ndef quad(a, b, x, c=0):                           # function that will be decorated\\n    return a * (x ** 2) + b * x + c\\n\\n# we override the reference to the original function with a\\n# reference to the wrapper function returned by the decorator.\\n# overriding is not necessary however.\\nlinear = debug(linear)\\nlinear(2, 5, b=8)                                 # should return 18, and print debugging statements\\nquad = debug(quad)\\nquad(2, 5, 2)                                     # should return 18, and print debugging statements\\n\")), mdx(\"p\", null, \"In the above example, the decorator returns a wrapper function to the original\\nfunction that executes additional code before and after the original function.\\nHowever, decorators can also be used to modify the functionality of the\\noriginal function or even modify the function itself.\"), mdx(\"p\", null, \"But, one thing still bothers us... we still have to write that extra piece of\\noverriding code for every single function we want to debug. This is where the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@\"), \" notation for decorators comes in handy.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def decorator(func):\\n    def wrapper(*args, **kwargs):\\n        print(f\\\"{func.__name__} is now decorated!\\\")\\n        return func(*args, **kwargs)\\n    return wrapper\\n\\n# after the decoration, linear no longer points to the original\\n# function, but rather the wrapper returned by the decorator\\n@decorator\\ndef linear(m, x, b=0):\\n    return m * x + b\\n\\nlinear(2, 5, b=8)  # linear is now already decorated by the decorator\\n\")), mdx(\"p\", null, \"Now that we understand how a basic decorator works, another question arises,\\nwhat if we want to customize our decorator (customizing the template itself!?)\\nIn a normal decorator, the only thing that changes in a wrapper is the\\nfunction that is invoked, but if we want the wrapper itself to change, we need\\nto add another layer for parameterization, something I like to call a decorator\\nfactory.\"), mdx(\"p\", null, \"Let's extend our debugging example. What if we want to write the output from\\nthe debug statements to a file instead of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"stdout\"), \", and what if we want the\\nfilename to be different based on the function we want to debug? We can use\\na decorator factory to generate custom debug decorators.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def debug(filename):\\n    def debug_file(func):\\n        def wrapper(*args, **kwargs):\\n            with open(filename, 'w') as f:\\n                print(f\\\"debug {func.__name__}\\\", file=f)\\n                ret = func(*args, **kwargs)\\n                print(f\\\"{func.__name__} returned {ret}\\\", file=f)\\n            return ret\\n        return wrapper\\n    return debug_file\\n\\n@debug('linear.txt')                 # this will generate a decorator with filename='linear.txt'\\ndef linear(m, x, b=0):\\n    return m * x + b\\n\\n@debug('quad.txt')                   # this will generate a decorator with filename='quad.txt'\\ndef quad(a, b, x, c=0):\\n    return a * (x ** 2) + b * x + c\\n\\nlinear(2, 5, b=8)                    # this will write to linear.txt\\nquad(2, 5, 2)                        # this will write to quad.txt\\n\")), mdx(\"p\", null, \"PS: You can go a step further and reroute \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"all\"), \" output from the original\\nfunction into a file by temporarily overriding the destination of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sys.stdout\"), \"!\\nThis would be an example of modifying the original function's behavior using a\\ndecorator instead of just extending its behavior.\"), mdx(\"p\", null, \"Now that we understand how decorators and decorator factories work, the\\nfollowing are some use cases where you can utilize them:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Debugging a function (decorator)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Timing a function (decorator)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Counting calls to a function / singleton functions (decorator, but usually\\nmetaclasses are a better option)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Thread synchronization (decorator factory using a lock)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Parameter validation (decorator factory using args and kwargs!)\")), mdx(\"p\", null, \"And the following are some very useful built-in decorators available for use in\\nPython right now:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://docs.python.org/3/library/atexit.html#atexit.register\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"@atexit.register\")), \"\\n: executes the function on program termination\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://docs.python.org/3/library/functions.html#classmethod\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"@classmethod\")), \"\\n: returns a class method\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://docs.python.org/3/library/functions.html#staticmethod\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"@staticmethod\")), \"\\n: returns a static method\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://docs.python.org/3/library/functions.html#property\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"@property\")), \"\\n: returns a property\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://docs.python.org/3/library/functools.html#functools.cache\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"@functools.cache\")), \"\\nand \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://docs.python.org/3/library/functools.html#functools.lru_cache\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"@functools.lru_cache\")), \"\\n: useful for memoization\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://docs.python.org/3/library/functools.html#functools.wraps\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"@functools.wraps\")), \"\\n: a must-use decorator for the wrapper function to inherit properties from\\nthe original function\")), mdx(\"p\", null, \"Overall, this article gives an insight into how decorators and decorator\\nfactories work. These are some of the more complicated concepts in Python, but\\nwith the incremental examples and the potential uses of decorators, I hope\\nthe concepts are clearer.\"));\n}\n;\nMDXContent.isMDXComponent = true;","timeToRead":3,"fields":{"excerpt":"In Python, decorators are often shrouded by a layer of mystery. We tend to use\nthem without understanding how they work, but if understood properly, they can\nreally improve our efficiency. This blog will cover the fundamentals of\ndecorators, and assumes that you have an understanding of how functions work.","miscTimeToRead":12},"frontmatter":{"title":"Python Decorators","date":"2022-01-14T00:00:00.000Z","tags":["tech"],"slug":"/blogs/python-decorators"}}},"pageContext":{}},"staticQueryHashes":["63159454"]}